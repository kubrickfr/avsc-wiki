<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Types](#types)
  - [What is a `Type`?](#what-is-a-type)
  - [How do I get a `Type`?](#how-do-i-get-a-type)
  - [What about Avro files?](#what-about-avro-files)
  - [Next steps](#next-steps)
- [Services](#services)
  - [Defining a service](#defining-a-service)
  - [Server implementation](#server-implementation)
  - [Calling our service.](#calling-our-service)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Types

## What is a `Type`?

Each Avro type maps to a corresponding JavaScript [`Type`](API#class-type):

+ `int` maps to `IntType`.
+ `array`s map to `ArrayType`s.
+ `record`s map to `RecordType`s.
+ etc.

An instance of a `Type` knows how to [`decode`](Api#typedecodebuf-pos-resolver)
and [`encode`](Api#typeencodeval-buf-pos) its corresponding values. For example
the `StringType` knows how to handle JavaScript strings:

```javascript
const stringType = new avro.types.StringType();
const buf = stringType.toBuffer('Hi'); // Buffer containing 'Hi''s Avro encoding.
const str = stringType.fromBuffer(buf); // === 'Hi'
```

The [`toBuffer`](API#typetobufferval) and
[`fromBuffer`](API#typefrombufferval-resolver-nocheck) methods above are
convenience functions which encode and decode a single object into/from a
standalone buffer.

Each `type` also provides a variety of other methods. Here are a few (refer to
the [API documentation](API#avro-types) for the full list):

+ JSON-encoding:

  ```javascript
  const jsonString = type.toString('Hi'); // === '"Hi"'
  const str = type.fromString(jsonString); // === 'Hi'
  ```

+ Validity checks:

  ```javascript
  const b1 = stringType.isValid('hello'); // === true ('hello' is a valid string.)
  const b2 = stringType.isValid(-2); // === false (-2 is not.)
  ```

+ Random object generation:

  ```javascript
  const s = stringType.random(); // A random string.
  ```


## How do I get a `Type`?

It is possible to instantiate types directly by calling their constructors
(available in the `avro.types` namespace; this is what we used earlier), but in
the vast majority of use-cases they will be automatically generated by parsing
an existing schema.

`avsc` exposes a static method, `Type.forSchema`, to do the heavy lifting and
generate a type from its Avro schema definition:

```javascript
// Equivalent to what we did earlier.
const stringType = avro.Type.forSchema('string');

// A slightly more complex type.
const mapType = avro.Type.forSchema({type: 'map', values: 'long'});

// The sky is the limit!
const personType = avro.Type.forSchema({
  name: 'Person',
  type: 'record',
  fields: [
    {name: 'name', type: 'string'},
    {name: 'phone', type: ['null', 'string'], default: null},
    {name: 'address', type: {
      name: 'Address',
      type: 'record',
      fields: [
        {name: 'city', type: 'string'},
        {name: 'zip', type: 'int'}
      ]
    }}
  ]
});
```

Of course, all the `type` methods are available. For example:

```javascript
personType.isValid({
  name: 'Ann',
  phone: null,
  address: {city: 'Cambridge', zip: 02139}
}); // === true

personType.isValid({
  name: 'Bob',
  phone: {string: '617-000-1234'},
  address: {city: 'Boston'}
}); // === false (Missing the zip code.)
```

For advanced use-cases, `Type.forSchema` also has a few options which are
detailed the API documentation.


## What about Avro files?

Avro files (meaning [Avro object container files][object-container]) hold
serialized Avro records along with their schema. Reading them is as simple as
calling [`createFileDecoder`](Api#createfiledecoderpath-opts):

```javascript
const personStream = avro.createFileDecoder('./persons.avro');
```

`personStream` is a [readable stream][rstream] of decoded records, which we can
for example use as follows:

```javascript
personStream.on('data', function (person) {
  if (person.address.city === 'San Francisco') {
    doSomethingWith(person);
  }
});
```

In case we need the records' `type` or the file's codec, they are available by
listening to the `'metadata'` event:

```javascript
personStream.on('metadata', function (type, codec) { /* Something useful. */ });
```

To access a file's header synchronously, there also exists an
[`extractFileHeader`](Api#extractfileheaderpath-opts) method:

```javascript
const header = avro.extractFileHeader('persons.avro');
```

Writing to an Avro container file is possible using
[`createFileEncoder`](Api#createfileencoderpath-type-opts):

```javascript
const encoder = avro.createFileEncoder('./processed.avro', type);
```


## Next steps

The [API documentation](Api) provides a comprehensive list of available
functions and their options. The [Advanced usage section](Advanced-usage) goes
through a few examples to show how the API can be used, including remote
procedure calls.


# Services

Using Avro's RPC interface, we can implement portable and "type-safe" APIs:

+ Clients and servers can be implemented once and reused for many different
  communication protocols (in-memory, TCP, HTTP, etc.).
+ All data that flows through the API is automatically validated using its
  corresponding schema.

In this section, we'll walk through an example of building a simple link
management service similar to [bitly][].

## Defining a service

The first step to creating a service is to define its API or "protocol": the
available calls and their signature. There are a couple ways of defining
protocols; we can write JSON definitions directly, or we can define them using
Avro's IDL (which can then be compiled to JSON definitions). The latter is
typically more convenient so we will use this here.

```java
/** A simple service to shorten URLs. */
protocol LinkService {

  /** Map a URL to an alias, returns true if successful. */
  boolean createAlias(string alias, string url);

  /** Expand an alias, returning null if the alias doesn't exist. */
  union { null, string } expandAlias(string alias);
}
```

## Server implementation

```javascript
// The protocol generated from the above declaration (see the sample code for
// the complete snippet).
let protocol;

// In this example, we'll use a simple map as URL cache.
const cache = new Map();

// We now instantiate a server corresponding to our API and implement both
// calls.
const server = avro.Service.forProtocol(protocol)
  .createServer()
  .onCreateAlias(function (alias, url, cb) {
    if (cache.has(alias)) {
      cb(null, false); // The alias already exists, return false.
    } else {
      cache.set(alias, url); // Add the alias to the cache.
      cb(null, true);
    }
  })
  .onExpandAlias(function (alias, cb) {
    cb(null, cache.get(alias) || null);
  });
```

## Calling our service.

TODO


[bitly]: https://bitly.com/
[object-container]: https://avro.apache.org/docs/current/spec.html#Object+Container+Files
[rstream]: https://nodejs.org/api/stream.html#stream_class_stream_readable
