<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [Types](#types)
  - [What is a `Type`?](#what-is-a-type)
  - [How do I get a `Type`?](#how-do-i-get-a-type)
  - [What about Avro files?](#what-about-avro-files)
  - [Next steps](#next-steps)
- [Services](#services)
  - [Defining the `Service`](#defining-the-service)
  - [Server implementation](#server-implementation)
  - [Calling our service](#calling-our-service)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# Types

## What is a `Type`?

Each Avro type maps to a corresponding JavaScript [`Type`](API#class-type):

+ `int` maps to `IntType`.
+ `array`s map to `ArrayType`s.
+ `record`s map to `RecordType`s.
+ etc.

An instance of a `Type` knows how to [`decode`](Api#typedecodebuf-pos-resolver)
and [`encode`](Api#typeencodeval-buf-pos) its corresponding values. For example
the `StringType` knows how to handle JavaScript strings:

```javascript
const stringType = new avro.types.StringType();
const buf = stringType.toBuffer('Hi'); // Buffer containing 'Hi''s Avro encoding.
const str = stringType.fromBuffer(buf); // === 'Hi'
```

The [`toBuffer`](API#typetobufferval) and
[`fromBuffer`](API#typefrombufferval-resolver-nocheck) methods above are
convenience functions which encode and decode a single object into/from a
standalone buffer.

Each `type` also provides a variety of other methods. Here are a few (refer to
the [API documentation](API#avro-types) for the full list):

+ JSON-encoding:

  ```javascript
  const jsonString = type.toString('Hi'); // === '"Hi"'
  const str = type.fromString(jsonString); // === 'Hi'
  ```

+ Validity checks:

  ```javascript
  const b1 = stringType.isValid('hello'); // === true ('hello' is a valid string.)
  const b2 = stringType.isValid(-2); // === false (-2 is not.)
  ```

+ Random object generation:

  ```javascript
  const s = stringType.random(); // A random string.
  ```


## How do I get a `Type`?

It is possible to instantiate types directly by calling their constructors
(available in the `avro.types` namespace; this is what we used earlier), but in
the vast majority of use-cases they will be automatically generated by parsing
an existing schema.

`avsc` exposes a static method, `Type.forSchema`, to do the heavy lifting and
generate a type from its Avro schema definition:

```javascript
// Equivalent to what we did earlier.
const stringType = avro.Type.forSchema('string');

// A slightly more complex type.
const mapType = avro.Type.forSchema({type: 'map', values: 'long'});

// The sky is the limit!
const personType = avro.Type.forSchema({
  name: 'Person',
  type: 'record',
  fields: [
    {name: 'name', type: 'string'},
    {name: 'phone', type: ['null', 'string'], default: null},
    {name: 'address', type: {
      name: 'Address',
      type: 'record',
      fields: [
        {name: 'city', type: 'string'},
        {name: 'zip', type: 'int'}
      ]
    }}
  ]
});
```

Of course, all the `type` methods are available. For example:

```javascript
personType.isValid({
  name: 'Ann',
  phone: null,
  address: {city: 'Cambridge', zip: 02139}
}); // === true

personType.isValid({
  name: 'Bob',
  phone: {string: '617-000-1234'},
  address: {city: 'Boston'}
}); // === false (Missing the zip code.)
```

For advanced use-cases, `Type.forSchema` also has a few options which are
detailed the API documentation.


## What about Avro files?

Avro files (meaning [Avro object container files][object-container]) hold
serialized Avro records along with their schema. Reading them is as simple as
calling [`createFileDecoder`](Api#createfiledecoderpath-opts):

```javascript
const personStream = avro.createFileDecoder('./persons.avro');
```

`personStream` is a [readable stream][rstream] of decoded records, which we can
for example use as follows:

```javascript
personStream.on('data', function (person) {
  if (person.address.city === 'San Francisco') {
    doSomethingWith(person);
  }
});
```

In case we need the records' `type` or the file's codec, they are available by
listening to the `'metadata'` event:

```javascript
personStream.on('metadata', function (type, codec) { /* Something useful. */ });
```

To access a file's header synchronously, there also exists an
[`extractFileHeader`](Api#extractfileheaderpath-opts) method:

```javascript
const header = avro.extractFileHeader('persons.avro');
```

Writing to an Avro container file is possible using
[`createFileEncoder`](Api#createfileencoderpath-type-opts):

```javascript
const encoder = avro.createFileEncoder('./processed.avro', type);
```


## Next steps

The [API documentation](Api) provides a comprehensive list of available
functions and their options. The [Advanced usage section](Advanced-usage) goes
through a few examples to show how the API can be used, including remote
procedure calls.


# Services

Using Avro's RPC interface, we can implement portable and "type-safe" APIs:

+ Clients and servers can be implemented once and reused for many different
  communication protocols (in-memory, TCP, HTTP, etc.).
+ All data that flows through the API is automatically validated using its
  corresponding schema. Function arguments and return values are therefore
  guaranteed to match the type specified in the API.

In this section, we'll walk through an example of building a simple link
management service similar to [bitly][].

## Defining the `Service`

The first step to creating a service is to define its _protocol_, describing
the available API calls and their signature. There are a couple ways of doing
so; we can write JSON definitions directly, or we can use Avro's IDL syntax
(which can then be compiled to JSON definitions). The latter is typically more
convenient so we will use this here.

```java
/** A simple service to shorten URLs. */
protocol LinkService {

  /** Map a URL to an alias. */
  null createAlias(string alias, string url);

  /** Expand an alias, returning null if the alias doesn't exist. */
  union { null, string } expandAlias(string alias);
}
```

With the above spec saved to a file, say `LinkService.avdl`, we can instantiate
the corresponding service as follows:

```javascript
// We first compile the IDL specification into a JSON protocol.
avro.assembleProtocol('./LinkService.avdl', function (err, protocol) {
  // From which we can create our service.
  const service = avro.Service.fromProtocol(protocol);
});
```

The `service` object can then be used generate clients and servers, as
described in the following sections.

## Server implementation

So far, we haven't said anything about how API responses will be computed. This
is where servers come in: server provide the logic powering our API.

```javascript
const urlCache = new Map(); // We'll use an in-memory map to store links.

// We instantiate a server corresponding to our API and implement both calls.
const server = service.createServer()
  .onCreateAlias(function (alias, url, cb) {
    if (urlCache.has(alias)) {
      cb(new Error('alias already exists'));
    } else {
      urlCache.set(alias, url); // Add the alias to the cache.
      cb();
    }
  })
  .onExpandAlias(function (alias, cb) {
    cb(null, urlCache.get(alias));
  });
```

Notice that no part of the above implementation is coupled to a particular
communication scheme (e.g. HTTP, TCP, AMQP): the code we wrote is
_transport-agnostic_. The following section shows how to instantiate two
different clients.

## Calling our service

The simplest way to call our service is use an in-memory client, passing in our
`server` above as option to `service.createClient`:

```javascript
const client = service.createClient({server});

// We first send a request to create an alias.
client.createAlias('hn', 'https://news.ycombinator.com/', function (err) {
  // Which we can now expand.
  client.expandAlias('hn', function (err, url) {
    console.log(`hn is currently aliased to ${url}`);
  });
});
```

We can also use the same server and client to communicate over any binary
streams, for example TCP sockets:

```javascript
const net = require('net');

// Set up the server to listen to incoming connections on port 24950.
net.createServer()
  .on('connection', function (con) { server.createChannel(con); })
  .listen(24950);

// And create a matching client:
const client = service.createClient({transport: net.connect(24950)});
```


[bitly]: https://bitly.com/
[object-container]: https://avro.apache.org/docs/current/spec.html#Object+Container+Files
[rstream]: https://nodejs.org/api/stream.html#stream_class_stream_readable
